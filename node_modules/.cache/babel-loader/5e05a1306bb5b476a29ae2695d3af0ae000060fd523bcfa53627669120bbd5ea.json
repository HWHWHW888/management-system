{"ast":null,"code":"// Database wrapper that uses backend API instead of direct Supabase calls\nimport { apiClient } from './apiClient';\nimport { supabase } from '../supabase/supabaseClients';\nexport class DatabaseWrapper {\n  constructor() {\n    // Expose API client for direct access to customer methods\n    this.apiClient = apiClient;\n    this.connectionCache = null;\n    this.CACHE_DURATION = 30000;\n  }\n  // 30 seconds cache\n\n  async testConnection() {\n    try {\n      // Check cache first\n      if (this.connectionCache) {\n        const now = Date.now();\n        if (now - this.connectionCache.timestamp < this.CACHE_DURATION) {\n          console.log('‚ö° Using cached connection result');\n          return this.connectionCache.result;\n        }\n      }\n\n      // Test backend API health with timeout\n      const apiUrl = process.env.REACT_APP_API_URL || 'http://localhost:3001';\n      const controller = new AbortController();\n      const timeoutId = setTimeout(() => controller.abort(), 5000); // 5 second timeout\n\n      const response = await fetch(`${apiUrl === null || apiUrl === void 0 ? void 0 : apiUrl.replace('/api', '')}/health`, {\n        signal: controller.signal\n      });\n      clearTimeout(timeoutId);\n      const data = await response.json();\n      const result = response.ok && data.status === 'OK' ? {\n        success: true,\n        message: 'Connected successfully',\n        details: 'Backend API connection is healthy'\n      } : {\n        success: false,\n        message: 'Connection failed',\n        details: 'Backend API is not responding'\n      };\n\n      // Cache the result\n      this.connectionCache = {\n        result,\n        timestamp: Date.now()\n      };\n      return result;\n    } catch (error) {\n      const result = {\n        success: false,\n        message: 'Connection error',\n        details: error.name === 'AbortError' ? 'Connection timeout' : error.message\n      };\n\n      // Cache failed result for shorter time\n      this.connectionCache = {\n        result,\n        timestamp: Date.now() - (this.CACHE_DURATION - 5000) // Cache for only 5 seconds\n      };\n      return result;\n    }\n  }\n  async isHealthy() {\n    try {\n      const connectionTest = await this.testConnection();\n      return connectionTest.success;\n    } catch (err) {\n      console.error('‚ùå Database health check error:', err);\n      return false;\n    }\n  }\n  async get(table, filters = []) {\n    try {\n      let data = [];\n      switch (table) {\n        case 'users':\n          const usersResponse = await apiClient.getUsers();\n          data = usersResponse.success ? usersResponse.data || [] : [];\n          break;\n        case 'customers':\n          const customersResponse = await apiClient.getCustomers();\n          data = customersResponse.success ? customersResponse.data || [] : [];\n          break;\n        case 'agents':\n          const agentsResponse = await apiClient.getAgents();\n          data = agentsResponse.success ? agentsResponse.data || [] : [];\n          break;\n        case 'trips':\n          const tripsResponse = await apiClient.getTrips();\n          data = tripsResponse.success ? tripsResponse.data || [] : [];\n          break;\n        case 'transactions':\n          const transactionsResponse = await apiClient.getTransactions();\n          data = transactionsResponse.success ? transactionsResponse.data || [] : [];\n          break;\n        case 'staff':\n          const staffResponse = await apiClient.getStaffs();\n          data = staffResponse.success ? staffResponse.data || [] : [];\n          break;\n        case 'rolling_records':\n          const rollingResponse = await apiClient.get('/rolling-records');\n          data = rollingResponse.success ? rollingResponse.data || [] : [];\n          break;\n        default:\n          console.warn(`Table ${table} not supported in API wrapper`);\n          return [];\n      }\n\n      // Apply filters if provided\n      if (filters.length > 0) {\n        data = data.filter(item => {\n          return filters.every(filter => {\n            if (filter.column && filter.value !== undefined) {\n              return item[filter.column] === filter.value;\n            }\n            return true;\n          });\n        });\n      }\n      return data || [];\n    } catch (error) {\n      console.error(`Error fetching from ${table}:`, error);\n      return [];\n    }\n  }\n  async save(table, data) {\n    try {\n      // For now, we'll handle single record creation\n      // In a real implementation, you'd want batch operations\n      const results = [];\n      for (const record of data) {\n        let result;\n        switch (table) {\n          case 'users':\n            result = await apiClient.createUser(record);\n            break;\n          case 'customers':\n            result = await apiClient.createCustomer(record);\n            break;\n          case 'agents':\n            result = await apiClient.createAgent(record);\n            break;\n          case 'trips':\n            result = await apiClient.createTrip(record);\n            break;\n          case 'transactions':\n            result = await apiClient.createTransaction(record);\n            break;\n          default:\n            throw new Error(`Table ${table} not supported for save operation`);\n        }\n        results.push(result);\n      }\n      return {\n        success: true,\n        results\n      };\n    } catch (error) {\n      console.error(`Error saving to ${table}:`, error);\n      throw error;\n    }\n  }\n  async initializeTables() {\n    try {\n      console.log('üîÑ Backend API handles table initialization...');\n      // Backend API handles table initialization\n      return true;\n    } catch (error) {\n      console.error('‚ùå Database initialization failed:', error);\n      throw error;\n    }\n  }\n  async initializeSampleDataIfNeeded() {\n    try {\n      // Quick check if admin user exists with timeout\n      const checkUserPromise = supabase.from('users').select('username').eq('username', 'admin').single();\n      const timeoutPromise = new Promise((_, reject) => setTimeout(() => reject(new Error('Check timeout')), 3000));\n      const {\n        data: existingUser\n      } = await Promise.race([checkUserPromise, timeoutPromise]);\n      if (!existingUser) {\n        console.log('üîß Creating admin user...');\n\n        // Parallel user creation with error handling\n        const authPromise = supabase.auth.signUp({\n          email: 'admin@casino.com',\n          password: 'admin123',\n          options: {\n            data: {\n              username: 'admin',\n              role: 'admin'\n            }\n          }\n        }).catch(err => {\n          console.warn('Auth creation skipped:', err.message);\n          return {\n            data: {\n              user: {\n                id: 'admin-1'\n              }\n            }\n          };\n        });\n        const profilePromise = supabase.from('users').insert([{\n          id: 'admin-1',\n          username: 'admin',\n          password: 'admin123',\n          role: 'admin'\n        }]).then(() => console.log('Profile created')).catch(err => {\n          if (!err.message.includes('duplicate')) {\n            console.warn('Profile creation failed:', err);\n          }\n        });\n\n        // Execute in parallel with timeout\n        await Promise.race([Promise.all([authPromise, profilePromise]), new Promise((_, reject) => setTimeout(() => reject(new Error('Initialization timeout')), 5000))]);\n        console.log('‚úÖ Admin user initialized');\n      } else {\n        console.log('‚ö° Admin user already exists - skipping');\n      }\n    } catch (error) {\n      if (error.message === 'Check timeout' || error.message === 'Initialization timeout') {\n        console.warn('‚ö†Ô∏è User initialization timed out - continuing anyway');\n      } else {\n        console.error('Error initializing sample data:', error);\n      }\n      // Don't throw - continue with app initialization\n    }\n  }\n  async login(username, password) {\n    try {\n      var _responseData$data;\n      console.log('üîê DatabaseWrapper: Starting login process...');\n      const response = await apiClient.login(username, password);\n      console.log('üîê DatabaseWrapper: Login response:', response);\n      if (!response.success) {\n        throw new Error(response.error || 'Login failed');\n      }\n\n      // ApiClient now handles token storage automatically\n      // Just extract the user data from the response\n      const responseData = response.data;\n      let user = null;\n      let token = null;\n      if (responseData !== null && responseData !== void 0 && (_responseData$data = responseData.data) !== null && _responseData$data !== void 0 && _responseData$data.user) {\n        user = responseData.data.user;\n        token = responseData.data.token;\n      } else if (responseData !== null && responseData !== void 0 && responseData.user) {\n        user = responseData.user;\n        token = responseData.token;\n      } else {\n        // Fallback - create user from response data\n        user = {\n          id: (responseData === null || responseData === void 0 ? void 0 : responseData.id) || 'admin-1',\n          username: (responseData === null || responseData === void 0 ? void 0 : responseData.username) || username,\n          role: (responseData === null || responseData === void 0 ? void 0 : responseData.role) || 'admin'\n        };\n      }\n      console.log('üîë DatabaseWrapper: User extracted:', user);\n      console.log('üîë DatabaseWrapper: Token present:', token ? 'YES' : 'NO');\n\n      // ApiClient already saved to localStorage and set tokens\n      // Just return the user object\n      return user;\n    } catch (error) {\n      console.error('Login error:', error);\n      throw error;\n    }\n  }\n\n  // Clear all data for fresh start\n  async clearAllDataForFreshStart() {\n    try {\n      console.log('‚ö†Ô∏è Clear data operation should be handled by backend API');\n      // This would need to be implemented as an admin endpoint\n      return true;\n    } catch (error) {\n      console.error('Error during fresh start:', error);\n      throw error;\n    }\n  }\n\n  // Export all data\n  async exportAllData() {\n    try {\n      const exportData = {};\n      const tables = ['users', 'agents', 'customers', 'trips', 'transactions'];\n      for (const table of tables) {\n        const data = await this.get(table, []);\n        exportData[table] = data || [];\n      }\n      return exportData;\n    } catch (error) {\n      console.error('Error exporting data:', error);\n      throw error;\n    }\n  }\n\n  // Import all data\n  async importAllData(data) {\n    try {\n      const tables = ['users', 'agents', 'customers', 'trips', 'transactions'];\n      for (const table of tables) {\n        if (data[table] && Array.isArray(data[table]) && data[table].length > 0) {\n          await this.save(table, data[table]);\n        }\n      }\n      return true;\n    } catch (error) {\n      console.error('Error importing data:', error);\n      return false;\n    }\n  }\n\n  // Get database statistics\n  getStats() {\n    return {\n      mode: 'api',\n      healthy: true,\n      lastHealthCheck: new Date().toISOString(),\n      backupCount: 0\n    };\n  }\n\n  // Get available backups\n  getAvailableBackups() {\n    return [];\n  }\n\n  // Staff management methods\n  async getStaffs() {\n    try {\n      console.log('üìã DatabaseWrapper: Fetching all staff members...');\n      const response = await apiClient.getStaffs();\n      if (!response.success) {\n        throw new Error(response.error || 'Failed to fetch staff members');\n      }\n      return response.data || [];\n    } catch (error) {\n      console.error('‚ùå DatabaseWrapper: Error fetching staff:', error);\n      throw error;\n    }\n  }\n  async getStaff(id) {\n    try {\n      console.log(`üìã DatabaseWrapper: Fetching staff member: ${id}`);\n      const response = await apiClient.getStaff(id);\n      if (!response.success) {\n        throw new Error(response.error || 'Failed to fetch staff member');\n      }\n      return response.data;\n    } catch (error) {\n      console.error('‚ùå DatabaseWrapper: Error fetching staff:', error);\n      throw error;\n    }\n  }\n  async createStaff(staffData) {\n    try {\n      console.log('üë§ DatabaseWrapper: Creating staff member...');\n      const response = await apiClient.createStaff(staffData);\n      if (!response.success) {\n        throw new Error(response.error || 'Failed to create staff member');\n      }\n      return response.data;\n    } catch (error) {\n      console.error('‚ùå DatabaseWrapper: Error creating staff:', error);\n      throw error;\n    }\n  }\n  async updateStaff(id, staffData) {\n    try {\n      console.log(`üë§ DatabaseWrapper: Updating staff member: ${id}`);\n      const response = await apiClient.updateStaff(id, staffData);\n      if (!response.success) {\n        throw new Error(response.error || 'Failed to update staff member');\n      }\n      return response.data;\n    } catch (error) {\n      console.error('‚ùå DatabaseWrapper: Error updating staff:', error);\n      throw error;\n    }\n  }\n  async deleteStaff(id) {\n    try {\n      console.log(`üóëÔ∏è DatabaseWrapper: Deleting staff member: ${id}`);\n      const response = await apiClient.deleteStaff(id);\n      if (!response.success) {\n        throw new Error(response.error || 'Failed to delete staff member');\n      }\n      return response.data;\n    } catch (error) {\n      console.error('‚ùå DatabaseWrapper: Error deleting staff:', error);\n      throw error;\n    }\n  }\n  async staffCheckIn(id, checkInData) {\n    try {\n      console.log(`‚è∞ DatabaseWrapper: Staff check-in: ${id}`);\n      const response = await apiClient.staffCheckIn(id, checkInData);\n      if (!response.success) {\n        throw new Error(response.error || 'Failed to check in staff member');\n      }\n      return response.data;\n    } catch (error) {\n      console.error('‚ùå DatabaseWrapper: Error checking in staff:', error);\n      throw error;\n    }\n  }\n  async staffCheckOut(id, checkOutData) {\n    try {\n      console.log(`‚è∞ DatabaseWrapper: Staff check-out: ${id}`);\n      const response = await apiClient.staffCheckOut(id, checkOutData);\n      if (!response.success) {\n        throw new Error(response.error || 'Failed to check out staff member');\n      }\n      return response.data;\n    } catch (error) {\n      console.error('‚ùå DatabaseWrapper: Error checking out staff:', error);\n      throw error;\n    }\n  }\n  async getStaffShifts(id, params) {\n    try {\n      console.log(`üìã DatabaseWrapper: Fetching shifts for staff: ${id}`);\n      const response = await apiClient.getStaffShifts(id, params);\n      if (!response.success) {\n        throw new Error(response.error || 'Failed to fetch staff shifts');\n      }\n      return response.data || [];\n    } catch (error) {\n      console.error('‚ùå DatabaseWrapper: Error fetching staff shifts:', error);\n      throw error;\n    }\n  }\n  async getStaffRollingRecords(id, params) {\n    try {\n      console.log(`üìã DatabaseWrapper: Fetching rolling records for staff: ${id}`);\n      const response = await apiClient.getStaffRollingRecords(id, params);\n      if (!response.success) {\n        throw new Error(response.error || 'Failed to fetch staff rolling records');\n      }\n      return response.data || [];\n    } catch (error) {\n      console.error('‚ùå DatabaseWrapper: Error fetching staff rolling records:', error);\n      throw error;\n    }\n  }\n}\n\n// Export the wrapped database instance\nexport const db = new DatabaseWrapper();","map":{"version":3,"names":["apiClient","supabase","DatabaseWrapper","constructor","connectionCache","CACHE_DURATION","testConnection","now","Date","timestamp","console","log","result","apiUrl","process","env","REACT_APP_API_URL","controller","AbortController","timeoutId","setTimeout","abort","response","fetch","replace","signal","clearTimeout","data","json","ok","status","success","message","details","error","name","isHealthy","connectionTest","err","get","table","filters","usersResponse","getUsers","customersResponse","getCustomers","agentsResponse","getAgents","tripsResponse","getTrips","transactionsResponse","getTransactions","staffResponse","getStaffs","rollingResponse","warn","length","filter","item","every","column","value","undefined","save","results","record","createUser","createCustomer","createAgent","createTrip","createTransaction","Error","push","initializeTables","initializeSampleDataIfNeeded","checkUserPromise","from","select","eq","single","timeoutPromise","Promise","_","reject","existingUser","race","authPromise","auth","signUp","email","password","options","username","role","catch","user","id","profilePromise","insert","then","includes","all","login","_responseData$data","responseData","token","clearAllDataForFreshStart","exportAllData","exportData","tables","importAllData","Array","isArray","getStats","mode","healthy","lastHealthCheck","toISOString","backupCount","getAvailableBackups","getStaff","createStaff","staffData","updateStaff","deleteStaff","staffCheckIn","checkInData","staffCheckOut","checkOutData","getStaffShifts","params","getStaffRollingRecords","db"],"sources":["/Users/user/Desktop/Cursor New Management System/management-system-1/Junket Management System Source Code/src/utils/api/databaseWrapper.ts"],"sourcesContent":["// Database wrapper that uses backend API instead of direct Supabase calls\nimport { apiClient } from './apiClient';\nimport { supabase } from '../supabase/supabaseClients';\n\nexport class DatabaseWrapper {\n  // Expose API client for direct access to customer methods\n  public apiClient = apiClient;\n  private connectionCache: { result: any; timestamp: number } | null = null;\n  private readonly CACHE_DURATION = 30000; // 30 seconds cache\n\n  async testConnection() {\n    try {\n      // Check cache first\n      if (this.connectionCache) {\n        const now = Date.now();\n        if (now - this.connectionCache.timestamp < this.CACHE_DURATION) {\n          console.log('‚ö° Using cached connection result');\n          return this.connectionCache.result;\n        }\n      }\n\n      // Test backend API health with timeout\n      const apiUrl = process.env.REACT_APP_API_URL || 'http://localhost:3001';\n      const controller = new AbortController();\n      const timeoutId = setTimeout(() => controller.abort(), 5000); // 5 second timeout\n      \n      const response = await fetch(`${apiUrl?.replace('/api', '')}/health`, {\n        signal: controller.signal\n      });\n      clearTimeout(timeoutId);\n      \n      const data = await response.json();\n      \n      const result = response.ok && data.status === 'OK' ? {\n        success: true,\n        message: 'Connected successfully',\n        details: 'Backend API connection is healthy'\n      } : {\n        success: false,\n        message: 'Connection failed',\n        details: 'Backend API is not responding'\n      };\n\n      // Cache the result\n      this.connectionCache = {\n        result,\n        timestamp: Date.now()\n      };\n\n      return result;\n    } catch (error: any) {\n      const result = {\n        success: false,\n        message: 'Connection error',\n        details: error.name === 'AbortError' ? 'Connection timeout' : error.message\n      };\n\n      // Cache failed result for shorter time\n      this.connectionCache = {\n        result,\n        timestamp: Date.now() - (this.CACHE_DURATION - 5000) // Cache for only 5 seconds\n      };\n\n      return result;\n    }\n  }\n\n  async isHealthy() {\n    try {\n      const connectionTest = await this.testConnection();\n      return connectionTest.success;\n    } catch (err) {\n      console.error('‚ùå Database health check error:', err);\n      return false;\n    }\n  }\n\n  async get(table: string, filters: Array<{column: string, value: any}> = []) {\n    try {\n      let data = [];\n      \n      switch (table) {\n        case 'users':\n          const usersResponse = await apiClient.getUsers();\n          data = usersResponse.success ? (usersResponse.data as any[]) || [] : [];\n          break;\n        case 'customers':\n          const customersResponse = await apiClient.getCustomers();\n          data = customersResponse.success ? (customersResponse.data as any[]) || [] : [];\n          break;\n        case 'agents':\n          const agentsResponse = await apiClient.getAgents();\n          data = agentsResponse.success ? (agentsResponse.data as any[]) || [] : [];\n          break;\n        case 'trips':\n          const tripsResponse = await apiClient.getTrips();\n          data = tripsResponse.success ? (tripsResponse.data as any[]) || [] : [];\n          break;\n        case 'transactions':\n          const transactionsResponse = await apiClient.getTransactions();\n          data = transactionsResponse.success ? (transactionsResponse.data as any[]) || [] : [];\n          break;\n        case 'staff':\n          const staffResponse = await apiClient.getStaffs();\n          data = staffResponse.success ? (staffResponse.data as any[]) || [] : [];\n          break;\n        case 'rolling_records':\n          const rollingResponse = await apiClient.get('/rolling-records');\n          data = rollingResponse.success ? (rollingResponse.data as any[]) || [] : [];\n          break;\n        default:\n          console.warn(`Table ${table} not supported in API wrapper`);\n          return [];\n      }\n\n      // Apply filters if provided\n      if (filters.length > 0) {\n        data = data.filter((item: any) => {\n          return filters.every(filter => {\n            if (filter.column && filter.value !== undefined) {\n              return item[filter.column] === filter.value;\n            }\n            return true;\n          });\n        });\n      }\n\n      return data || [];\n    } catch (error) {\n      console.error(`Error fetching from ${table}:`, error);\n      return [];\n    }\n  }\n\n  async save(table: string, data: any[]) {\n    try {\n      // For now, we'll handle single record creation\n      // In a real implementation, you'd want batch operations\n      const results = [];\n      \n      for (const record of data) {\n        let result;\n        \n        switch (table) {\n          case 'users':\n            result = await apiClient.createUser(record);\n            break;\n          case 'customers':\n            result = await apiClient.createCustomer(record);\n            break;\n          case 'agents':\n            result = await apiClient.createAgent(record);\n            break;\n          case 'trips':\n            result = await apiClient.createTrip(record);\n            break;\n          case 'transactions':\n            result = await apiClient.createTransaction(record);\n            break;\n          default:\n            throw new Error(`Table ${table} not supported for save operation`);\n        }\n        \n        results.push(result);\n      }\n      \n      return { success: true, results };\n    } catch (error) {\n      console.error(`Error saving to ${table}:`, error);\n      throw error;\n    }\n  }\n\n  async initializeTables() {\n    try {\n      console.log('üîÑ Backend API handles table initialization...');\n      // Backend API handles table initialization\n      return true;\n    } catch (error) {\n      console.error('‚ùå Database initialization failed:', error);\n      throw error;\n    }\n  }\n\n  async initializeSampleDataIfNeeded() {\n    try {\n      // Quick check if admin user exists with timeout\n      const checkUserPromise = supabase\n        .from('users')\n        .select('username')\n        .eq('username', 'admin')\n        .single();\n      \n      const timeoutPromise = new Promise((_, reject) => \n        setTimeout(() => reject(new Error('Check timeout')), 3000)\n      );\n      \n      const { data: existingUser } = await Promise.race([\n        checkUserPromise,\n        timeoutPromise\n      ]) as any;\n      \n      if (!existingUser) {\n        console.log('üîß Creating admin user...');\n        \n        // Parallel user creation with error handling\n        const authPromise = supabase.auth.signUp({\n          email: 'admin@casino.com',\n          password: 'admin123',\n          options: {\n            data: { username: 'admin', role: 'admin' }\n          }\n        }).catch((err: any) => {\n          console.warn('Auth creation skipped:', err.message);\n          return { data: { user: { id: 'admin-1' } } };\n        });\n\n        const profilePromise = supabase\n          .from('users')\n          .insert([{\n            id: 'admin-1',\n            username: 'admin',\n            password: 'admin123',\n            role: 'admin'\n          }])\n          .then(() => console.log('Profile created'))\n          .catch((err: any) => {\n            if (!err.message.includes('duplicate')) {\n              console.warn('Profile creation failed:', err);\n            }\n          });\n\n        // Execute in parallel with timeout\n        await Promise.race([\n          Promise.all([authPromise, profilePromise]),\n          new Promise((_, reject) => \n            setTimeout(() => reject(new Error('Initialization timeout')), 5000)\n          )\n        ]);\n        \n        console.log('‚úÖ Admin user initialized');\n      } else {\n        console.log('‚ö° Admin user already exists - skipping');\n      }\n    } catch (error: any) {\n      if (error.message === 'Check timeout' || error.message === 'Initialization timeout') {\n        console.warn('‚ö†Ô∏è User initialization timed out - continuing anyway');\n      } else {\n        console.error('Error initializing sample data:', error);\n      }\n      // Don't throw - continue with app initialization\n    }\n  }\n\n  async login(username: string, password: string) {\n    try {\n      console.log('üîê DatabaseWrapper: Starting login process...');\n      const response = await apiClient.login(username, password);\n      console.log('üîê DatabaseWrapper: Login response:', response);\n      \n      if (!response.success) {\n        throw new Error((response as any).error || 'Login failed');\n      }\n      \n      // ApiClient now handles token storage automatically\n      // Just extract the user data from the response\n      const responseData = response.data as any;\n      let user = null;\n      let token = null;\n      \n      if (responseData?.data?.user) {\n        user = responseData.data.user;\n        token = responseData.data.token;\n      } else if (responseData?.user) {\n        user = responseData.user;\n        token = responseData.token;\n      } else {\n        // Fallback - create user from response data\n        user = {\n          id: responseData?.id || 'admin-1',\n          username: responseData?.username || username,\n          role: responseData?.role || 'admin'\n        };\n      }\n      \n      console.log('üîë DatabaseWrapper: User extracted:', user);\n      console.log('üîë DatabaseWrapper: Token present:', token ? 'YES' : 'NO');\n      \n      // ApiClient already saved to localStorage and set tokens\n      // Just return the user object\n      return user;\n      \n    } catch (error) {\n      console.error('Login error:', error);\n      throw error;\n    }\n  }\n\n  // Clear all data for fresh start\n  async clearAllDataForFreshStart() {\n    try {\n      console.log('‚ö†Ô∏è Clear data operation should be handled by backend API');\n      // This would need to be implemented as an admin endpoint\n      return true;\n    } catch (error) {\n      console.error('Error during fresh start:', error);\n      throw error;\n    }\n  }\n\n  // Export all data\n  async exportAllData() {\n    try {\n      const exportData: any = {};\n      \n      const tables = ['users', 'agents', 'customers', 'trips', 'transactions'];\n      \n      for (const table of tables) {\n        const data = await this.get(table, []);\n        exportData[table] = data || [];\n      }\n      \n      return exportData;\n    } catch (error) {\n      console.error('Error exporting data:', error);\n      throw error;\n    }\n  }\n\n  // Import all data\n  async importAllData(data: any) {\n    try {\n      const tables = ['users', 'agents', 'customers', 'trips', 'transactions'];\n      \n      for (const table of tables) {\n        if (data[table] && Array.isArray(data[table]) && data[table].length > 0) {\n          await this.save(table, data[table]);\n        }\n      }\n      \n      return true;\n    } catch (error) {\n      console.error('Error importing data:', error);\n      return false;\n    }\n  }\n\n  // Get database statistics\n  getStats() {\n    return {\n      mode: 'api',\n      healthy: true,\n      lastHealthCheck: new Date().toISOString(),\n      backupCount: 0\n    };\n  }\n\n  // Get available backups\n  getAvailableBackups() {\n    return [];\n  }\n\n  // Staff management methods\n  async getStaffs() {\n    try {\n      console.log('üìã DatabaseWrapper: Fetching all staff members...');\n      const response = await apiClient.getStaffs();\n      \n      if (!response.success) {\n        throw new Error(response.error || 'Failed to fetch staff members');\n      }\n      \n      return response.data || [];\n    } catch (error) {\n      console.error('‚ùå DatabaseWrapper: Error fetching staff:', error);\n      throw error;\n    }\n  }\n\n  async getStaff(id: string) {\n    try {\n      console.log(`üìã DatabaseWrapper: Fetching staff member: ${id}`);\n      const response = await apiClient.getStaff(id);\n      \n      if (!response.success) {\n        throw new Error(response.error || 'Failed to fetch staff member');\n      }\n      \n      return response.data;\n    } catch (error) {\n      console.error('‚ùå DatabaseWrapper: Error fetching staff:', error);\n      throw error;\n    }\n  }\n\n  async createStaff(staffData: any) {\n    try {\n      console.log('üë§ DatabaseWrapper: Creating staff member...');\n      const response = await apiClient.createStaff(staffData);\n      \n      if (!response.success) {\n        throw new Error(response.error || 'Failed to create staff member');\n      }\n      \n      return response.data;\n    } catch (error) {\n      console.error('‚ùå DatabaseWrapper: Error creating staff:', error);\n      throw error;\n    }\n  }\n\n  async updateStaff(id: string, staffData: any) {\n    try {\n      console.log(`üë§ DatabaseWrapper: Updating staff member: ${id}`);\n      const response = await apiClient.updateStaff(id, staffData);\n      \n      if (!response.success) {\n        throw new Error(response.error || 'Failed to update staff member');\n      }\n      \n      return response.data;\n    } catch (error) {\n      console.error('‚ùå DatabaseWrapper: Error updating staff:', error);\n      throw error;\n    }\n  }\n\n  async deleteStaff(id: string) {\n    try {\n      console.log(`üóëÔ∏è DatabaseWrapper: Deleting staff member: ${id}`);\n      const response = await apiClient.deleteStaff(id);\n      \n      if (!response.success) {\n        throw new Error(response.error || 'Failed to delete staff member');\n      }\n      \n      return response.data;\n    } catch (error) {\n      console.error('‚ùå DatabaseWrapper: Error deleting staff:', error);\n      throw error;\n    }\n  }\n\n  async staffCheckIn(id: string, checkInData: any) {\n    try {\n      console.log(`‚è∞ DatabaseWrapper: Staff check-in: ${id}`);\n      const response = await apiClient.staffCheckIn(id, checkInData);\n      \n      if (!response.success) {\n        throw new Error(response.error || 'Failed to check in staff member');\n      }\n      \n      return response.data;\n    } catch (error) {\n      console.error('‚ùå DatabaseWrapper: Error checking in staff:', error);\n      throw error;\n    }\n  }\n\n  async staffCheckOut(id: string, checkOutData: any) {\n    try {\n      console.log(`‚è∞ DatabaseWrapper: Staff check-out: ${id}`);\n      const response = await apiClient.staffCheckOut(id, checkOutData);\n      \n      if (!response.success) {\n        throw new Error(response.error || 'Failed to check out staff member');\n      }\n      \n      return response.data;\n    } catch (error) {\n      console.error('‚ùå DatabaseWrapper: Error checking out staff:', error);\n      throw error;\n    }\n  }\n\n  async getStaffShifts(id: string, params?: any) {\n    try {\n      console.log(`üìã DatabaseWrapper: Fetching shifts for staff: ${id}`);\n      const response = await apiClient.getStaffShifts(id, params);\n      \n      if (!response.success) {\n        throw new Error(response.error || 'Failed to fetch staff shifts');\n      }\n      \n      return response.data || [];\n    } catch (error) {\n      console.error('‚ùå DatabaseWrapper: Error fetching staff shifts:', error);\n      throw error;\n    }\n  }\n\n  async getStaffRollingRecords(id: string, params?: any) {\n    try {\n      console.log(`üìã DatabaseWrapper: Fetching rolling records for staff: ${id}`);\n      const response = await apiClient.getStaffRollingRecords(id, params);\n      \n      if (!response.success) {\n        throw new Error(response.error || 'Failed to fetch staff rolling records');\n      }\n      \n      return response.data || [];\n    } catch (error) {\n      console.error('‚ùå DatabaseWrapper: Error fetching staff rolling records:', error);\n      throw error;\n    }\n  }\n}\n\n// Export the wrapped database instance\nexport const db = new DatabaseWrapper();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}